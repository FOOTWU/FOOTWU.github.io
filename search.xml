<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言实例</title>
    <url>/2021/10/10/Cpost1/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打印素数</span><br><span class="line">判断闰年</span><br><span class="line">二分查找</span><br><span class="line">递归函数</span><br><span class="line">斐波那契数列</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="打印素数"><a href="#打印素数" class="headerlink" title="打印素数"></a>打印素数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int is_prime(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int j = 0;</span><br><span class="line">	for (int j = 2; j &lt; n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (n%j == 0)</span><br><span class="line">			return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	for ( i = 100; i &lt;=200 ; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (is_prime(i) == 1)</span><br><span class="line">			printf(&quot;%d\n&quot;,i);</span><br><span class="line">		&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int is_leap_yer(int y)</span><br><span class="line">&#123;</span><br><span class="line">	if ((y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0))</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int yer = 0;</span><br><span class="line">	for (int yer = 1000; yer &lt; 2000; yer++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (1 == is_leap_yer(yer))</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%d\n&quot;,yer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binary_search(int arr[],int k,int sz)</span><br><span class="line">&#123;</span><br><span class="line">	int left = 0;</span><br><span class="line">	int right = sz - 1;</span><br><span class="line">	while (left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = (left+right)/2;</span><br><span class="line">		if (arr[mid] &lt; k)</span><br><span class="line">		&#123;</span><br><span class="line">			left = mid+1;</span><br><span class="line">		&#125; else if(arr[mid] &gt; k)</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid - 1;</span><br><span class="line">		&#125; else</span><br><span class="line">		&#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">	int k = 5;</span><br><span class="line">	int sz = sizeof(arr)/ sizeof(arr[0]);</span><br><span class="line">	int ret = binary_search(arr,k,sz);</span><br><span class="line">	if (ret == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;找不到指定的数字\n&quot;);</span><br><span class="line">	&#125; else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;找到了，下标是: %d\n&quot;,ret);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归函数–"><a href="#递归函数–" class="headerlink" title="递归函数–"></a>递归函数–</h3><h4 id="输入数字-打印其所有数字"><a href="#输入数字-打印其所有数字" class="headerlink" title="输入数字 打印其所有数字"></a>输入数字 打印其所有数字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void print (int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (n &gt; 9)</span><br><span class="line">	&#123;</span><br><span class="line">		print(n/10);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\t&quot;,n%10);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int num = 0;</span><br><span class="line">	scanf(&quot;%d\t&quot;,&amp;num);</span><br><span class="line">	print(num);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算字符长度"><a href="#计算字符长度" class="headerlink" title="计算字符长度"></a>计算字符长度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 方法一</span><br><span class="line">int my_Strlen(char* str)</span><br><span class="line">&#123;</span><br><span class="line">	int count = 0;</span><br><span class="line">	while (*str != &#x27;\0&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line">方法二</span><br><span class="line">int my_Strlen(char* str)</span><br><span class="line">&#123;</span><br><span class="line">	if (*str != &#x27;\0&#x27;)</span><br><span class="line">		return 1+my_Strlen(str+1);</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char arr[50] = &#123;0&#125;;</span><br><span class="line">	scanf(&quot;%s\n&quot;,&amp;arr);</span><br><span class="line">	int len = my_Strlen(arr);</span><br><span class="line">	printf(&quot;len = %d\n&quot;,len);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一：递归</span><br><span class="line">int count;</span><br><span class="line">int Fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (n==3)// 测试第三个斐波那契数列的计算次数</span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (n&lt;=2)</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		return Fib(n-1)+ Fib(n-2);</span><br><span class="line">&#125;</span><br><span class="line">方法二：循环</span><br><span class="line">int Fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int a = 1;</span><br><span class="line">	int b = 1;</span><br><span class="line">	int c = 1;</span><br><span class="line">	while (n&gt;2)</span><br><span class="line">	&#123;</span><br><span class="line">		c = a+b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n = 0;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	ret = Fib(n);</span><br><span class="line">	printf(&quot;ret = %d\n&quot;,ret);</span><br><span class="line">	// printf(&quot;count = %d\n&quot;,count);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C语言动态内存数组</title>
    <url>/2021/10/10/Cpost3/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc-开辟内存空间块</span><br><span class="line">calloc-分配所需内存空间大小</span><br><span class="line">realloc-调整动态内存空间的大小</span><br><span class="line">free-释放空间</span><br><span class="line">常见动态内存的错误</span><br><span class="line">经典动态内存面试题</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="malloc-开辟内存空间块"><a href="#malloc-开辟内存空间块" class="headerlink" title="malloc-开辟内存空间块"></a>malloc-开辟内存空间块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数参数 void *malloc(size_t size)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //向内存申请10个整形的空间</span><br><span class="line">    int *p;</span><br><span class="line">    p = (int *) malloc(40);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //打印错误原因的一个方式</span><br><span class="line">        printf(&quot;%s\n&quot;,strerror(errno));</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        //正常使用空间</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            *(p + i) = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d\t&quot;,*(p + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当动态申请的空间不再使用的时候</span><br><span class="line">    //就应该还给操作系统</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calloc-分配所需内存空间大小"><a href="#calloc-分配所需内存空间大小" class="headerlink" title="calloc-分配所需内存空间大小"></a>calloc-分配所需内存空间大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数参数 void calloc(size_t nitems,size_t size)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = (int*)calloc(10,sizeof(int));</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,strerror(errno));</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,*(p+i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //free函数用于释放动态开辟的空间</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="realloc-调整动态内存空间的大小"><a href="#realloc-调整动态内存空间的大小" class="headerlink" title="realloc-调整动态内存空间的大小"></a>realloc-调整动态内存空间的大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realloc使用注意事项</span><br><span class="line"> 1.如果P指向的空间之后有足够的内存空间可以追加，则直接追加，后返回p</span><br><span class="line"> 2.如果P指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新找一个新的内存区域</span><br><span class="line">   开辟一块满足需求的空间，并且把原来内存中的数据拷贝回来，释放旧的内存空间</span><br><span class="line">   最后返回新开辟的内存空间地址</span><br><span class="line"> 3.得用一个新的变量来接收realloc函数的返回值</span><br><span class="line">函数参数 void realloc(size_t _Size)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p =(int*)malloc(20);</span><br><span class="line">    if (p = NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,strerror(errno));</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        int i =0;</span><br><span class="line">        for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            *(p+i) = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用realloc调整开辟空间大小</span><br><span class="line">    int* ptr = realloc(p,40);</span><br><span class="line">    if (ptr != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d&quot;,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常见动态内存的错误"><a href="#常见动态内存的错误" class="headerlink" title="常见动态内存的错误"></a>常见动态内存的错误</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.对NULL指针解引用操作</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = malloc(40);</span><br><span class="line">    //p进行相关的判断（判断是否为NULL指针）</span><br><span class="line">    *p = 10;//malloc开辟空间失败-有可能对NULL指针解引用</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2.对动态开辟内存的越界访问</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = (int*)malloc(40);//10个int 下标为0-9</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //越界(如果不想存在越界行为，就需算好范围)</span><br><span class="line">    int i = 0;</span><br><span class="line">    //将for里的i &lt;= 10 -&gt; i &lt; 10即可</span><br><span class="line">    for (int i = 0; i &lt;= 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">3.对非动态开辟内存使用free释放</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int *p = &amp;a;</span><br><span class="line">    //对非动态开辟内存使用free释放</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">4.使用free释放动态开辟内存的一部分</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = (int*)malloc(40);</span><br><span class="line">    if (p = NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //回收空间</span><br><span class="line">    //使用free释放动态开辟内存的一部分</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">5.对同一块动态内存的多次释放</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = (int*)malloc(40);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用</span><br><span class="line">    //释放</span><br><span class="line">    free(p);</span><br><span class="line">    //......</span><br><span class="line">    //为了避免多次释放空间，我们可以在第一个free下使用 p = NULL</span><br><span class="line">    //后续的free对程序没法造成影响</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">6.对动态开辟空间忘记释放（内存泄漏）</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        malloc(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="经典动态内存面试题"><a href="#经典动态内存面试题" class="headerlink" title="经典动态内存面试题"></a>经典动态内存面试题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.运行程序，会出现怎样的情况</span><br><span class="line">void GteMemory(char *p)</span><br><span class="line">&#123;</span><br><span class="line">    p = (char *)malloc(100);</span><br><span class="line">&#125;</span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *str = NULL;</span><br><span class="line">    GteMemory(str);</span><br><span class="line">    strcpy(str,&quot;hello world&quot;); //程序崩溃</span><br><span class="line">    printf(str);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//1.运行程序会出现崩溃的现象</span><br><span class="line">//2.程序存在内存泄漏的问题</span><br><span class="line">//str以值传递的形式给p p是GteMemory函数的形参，只能函数内部有效</span><br><span class="line">//等GteMemory函数返回之后，动态开辟内存尚未释放并且无法找到</span><br><span class="line">//所有会造成内存泄漏</span><br><span class="line">//改正确:</span><br><span class="line">void GteMemory(char **p)</span><br><span class="line">&#123;</span><br><span class="line">    *p = (char *)malloc(100);//*p进行接收</span><br><span class="line">&#125;</span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *str = NULL;</span><br><span class="line">    GteMemory(&amp;str);//取地址过去</span><br><span class="line">    strcpy(str,&quot;hello world&quot;);</span><br><span class="line">    printf(str);</span><br><span class="line">    //释放空间</span><br><span class="line">    free(str);</span><br><span class="line">    str = NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C语言的世界</title>
    <url>/2021/10/10/Cpost2/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型</span><br><span class="line">算术运算符</span><br><span class="line">关系运算符</span><br><span class="line">赋值运算符</span><br><span class="line">sizeof&amp;三元运算符</span><br><span class="line">运算符的优先级</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">类型名称（字节）    	数值大小</span><br><span class="line">---------------------------------------------</span><br><span class="line">char(1)   		-128 ~ 127  </span><br><span class="line">unsigned char(1)  	0 ~ 255</span><br><span class="line">int(4)  		-2147483648 ~ 2147483647</span><br><span class="line">unsigned int(4) 	0 ~ 4294967295</span><br><span class="line">short(2)		-32768 ~ 32768</span><br><span class="line">unsigned short(2)   	0 ~ 65535</span><br><span class="line">long(4)			-2147483648 ~ 2147483648</span><br><span class="line">unsigned long(4) 	0 ~ 4294967295</span><br><span class="line"><span class="built_in">float</span>(4) 		3.4E +/- 38(7 digits)</span><br><span class="line">double(8)		1.7E +/- 308(15 digits)</span><br><span class="line">long double(10)		1.2E +/- 4932(19 digits)</span><br></pre></td></tr></table></figure>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符	描述				实例</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">+	把两个操作数相加			A + B 将得到 30</span><br><span class="line">-	从第一个操作数中减去第二个操作数	A - B 将得到 -10</span><br><span class="line">*	把两个操作数相乘			A * B 将得到 200</span><br><span class="line">/	分子除以分母			B / A 将得到 2</span><br><span class="line">%	取模运算符，整除后的余数		B % A 将得到 0</span><br><span class="line">++	自增运算符，整数值增加 1		A++ 将得到 11</span><br><span class="line">--	自减运算符，整数值减少 1		A-- 将得到 9</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符	描述							实例</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">==	检查两个操作数的值是否相等，如果相等则条件为真。		(A == B) 为假。</span><br><span class="line">!=	检查两个操作数的值是否相等，如果不相等则条件为真。		(A != B) 为真。</span><br><span class="line">&gt;	检查左操作数的值是否大于右操作数的值，如果是则条件为真。		(A &gt; B) 为假。</span><br><span class="line">&lt;	检查左操作数的值是否小于右操作数的值，如果是则条件为真。		(A &lt; B) 为真。</span><br><span class="line">&gt;=	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A &gt;= B) 为假。</span><br><span class="line">&lt;=	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A &lt;= B) 为真。</span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符	描述							实例</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">=	简单的赋值运算符，把右边操作数的值赋给左边操作数		C = A + B 将把 A + B 的值赋给 C</span><br><span class="line">+=	加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数	C += A 相当于 C = C + A</span><br><span class="line">-=	减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数	C -= A 相当于 C = C - A</span><br><span class="line">*=	乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数	C *= A 相当于 C = C * A</span><br><span class="line">/=	除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数	C /= A 相当于 C = C / A</span><br><span class="line">%=	求模且赋值运算符，求两个操作数的模赋值给左边操作数		C %= A 相当于 C = C % A</span><br><span class="line">&lt;&lt;=	左移且赋值运算符						C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</span><br><span class="line">&gt;&gt;=	右移且赋值运算符						C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</span><br><span class="line">&amp;=	按位与且赋值运算符						C &amp;= 2 等同于 C = C &amp; 2</span><br><span class="line">^=	按位异或且赋值运算符					C ^= 2 等同于 C = C ^ 2</span><br><span class="line">|=	按位或且赋值运算符						C |= 2 等同于 C = C | 2</span><br></pre></td></tr></table></figure>

<h3 id="sizeof-amp-三元运算符"><a href="#sizeof-amp-三元运算符" class="headerlink" title="sizeof&amp;三元运算符"></a>sizeof&amp;三元运算符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符		描述		实例</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">sizeof()	返回变量的大小。	sizeof(a) 将返回 4，其中 a 是整数。</span><br><span class="line">&amp;		返回变量的地址。	&amp;a; 将给出变量的实际地址。</span><br><span class="line">*		指向一个变量。	*a; 将指向一个变量。</span><br><span class="line">? :		条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y</span><br></pre></td></tr></table></figure>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类别 		运算符 					结合性 </span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">后缀 		() [] -&gt; . ++ - -  			从左到右 </span><br><span class="line">一元 		+ - ! ~ ++ - - (type)* &amp; sizeof 	从右到左 </span><br><span class="line">乘除 		* / % 					从左到右 </span><br><span class="line">加减 		+ - 					从左到右 </span><br><span class="line">移位 		&lt;&lt; &gt;&gt; 					从左到右 </span><br><span class="line">关系 		&lt; &lt;= &gt; &gt;= 				从左到右 </span><br><span class="line">相等 		== != 					从左到右 </span><br><span class="line">位与 AND 	&amp; 					从左到右 </span><br><span class="line">位异或 XOR 	^ 					从左到右 </span><br><span class="line">位或 OR 	| 						从左到右 </span><br><span class="line">逻辑与 AND 	&amp;&amp; 					从左到右 </span><br><span class="line">逻辑或 OR 	|| 					从左到右 </span><br><span class="line">条件 		?: 					从右到左 </span><br><span class="line">赋值 		= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 	从右到左 </span><br><span class="line">逗号 		, 					从左到右 </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C语言函数讲解</title>
    <url>/2021/10/12/Cpost4/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strlen-字符串长度计算</span><br><span class="line">strcpy-字符串拷贝</span><br><span class="line">strcat-字符串追加</span><br><span class="line">strcmp-字符串比较</span><br><span class="line">strncpy-限制长度</span><br><span class="line">strncmp-字符串比较</span><br><span class="line">strstr - 查找字符串</span><br><span class="line">strtok-分隔字符串的特点符号</span><br><span class="line">strerror-错误信息提示</span><br><span class="line">memcpy-内存拷贝</span><br><span class="line">memmove-字节拷贝</span><br><span class="line">memcmp-比较内存</span><br><span class="line">memset-内存设置</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="strlen-字符串长度计算"><a href="#strlen-字符串长度计算" class="headerlink" title="strlen-字符串长度计算"></a>strlen-字符串长度计算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int my_strlen(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    assert(str != NULL);</span><br><span class="line">    while (*str != &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int len = my_strlen(&quot;abcdef&quot;);</span><br><span class="line">    printf(&quot;%d\n&quot;,len);</span><br><span class="line">    if(strlen(&quot;abc&quot;) - strlen(&quot;abcdef&quot;) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;hehe\n&quot;);</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;haha\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strcpy-字符串拷贝"><a href="#strcpy-字符串拷贝" class="headerlink" title="strcpy-字符串拷贝"></a>strcpy-字符串拷贝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* my_strcpy(char* dest,const char* src)</span><br><span class="line">&#123;</span><br><span class="line">    assert(dest != NULL);</span><br><span class="line">    assert(src != NULL);</span><br><span class="line">    char* ret = dest;</span><br><span class="line">    //拷贝src到指向的字符串到dest指向的空间，包含&#x27;\0&#x27;</span><br><span class="line">    while (*dest++ = *src++)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回目的空间的起始地址</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr1[] = &quot;abcdefghi&quot;;</span><br><span class="line">    char arr2[] = &quot;mke&quot;;</span><br><span class="line">    my_strcpy(arr1,arr2);</span><br><span class="line">    printf(&quot;%s\n&quot;,arr1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strcat-字符串追加"><a href="#strcat-字符串追加" class="headerlink" title="strcat-字符串追加"></a>strcat-字符串追加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* my_strcat(char* dest,const char* src)</span><br><span class="line">&#123;</span><br><span class="line">    char* ret = dest;</span><br><span class="line">    assert(dest != NULL);</span><br><span class="line">    assert(src);</span><br><span class="line">    //1.找到目的字符串&#x27;\0&#x27;</span><br><span class="line">    while (*dest != &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.追加</span><br><span class="line">    while (*dest++ = *src)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr1[30] = &quot;hello&quot;;</span><br><span class="line">    char arr2[] = &quot;world&quot;;</span><br><span class="line">    my_strcat(arr1,arr2);</span><br><span class="line">    printf(&quot;%S\n&quot;,arr1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strcmp-字符串比较"><a href="#strcmp-字符串比较" class="headerlink" title="strcmp-字符串比较"></a>strcmp-字符串比较</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数声明</span><br><span class="line">比较的是对应字符ascii码</span><br><span class="line">第一个大于第二个  返回·大于0的数字</span><br><span class="line">第一个等于第二个  返回等于0的数字</span><br><span class="line">第一个小于第二个  返回小于0的数字</span><br><span class="line">---------------------------------------</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1 = &quot;cbc&quot;;</span><br><span class="line">    char *p2 = &quot;dbc&quot;;</span><br><span class="line">    //int ret = strcmp(p1,p2);</span><br><span class="line">    if(strcmp(p1,p2) == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;p1 &gt; p2\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(strcmp(p1,p2) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;p1 = p2\n&quot;);</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int my_strcmp(const char* str1,const char* str2)</span><br><span class="line">&#123;</span><br><span class="line">    assert(str1 &amp;&amp; str2);</span><br><span class="line">    //比较</span><br><span class="line">    while (*str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*str1 == &#x27;\0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;//相等</span><br><span class="line">        &#125;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*str1 &gt; *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;//大于</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;//小于</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int my_strcmp(const char* str1,const char* str2)</span><br><span class="line">&#123;</span><br><span class="line">    assert(str1 &amp;&amp; str2);</span><br><span class="line">    //比较</span><br><span class="line">    while (*str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*str1 == &#x27;\0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;//相等</span><br><span class="line">        &#125;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return (*str1 - *str2);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char* p1 = &quot;abcdef&quot;;</span><br><span class="line">    char* p2 = &quot;qwert&quot;;</span><br><span class="line">    int ret = my_strcmp(p1,p2);</span><br><span class="line">    printf(&quot;ret = %d\n&quot;,ret);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strncpy-限制长度"><a href="#strncpy-限制长度" class="headerlink" title="strncpy-限制长度"></a>strncpy-限制长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr1[6] = &quot;abceft&quot;;</span><br><span class="line">    char arr2[] = &quot;dre&quot;;</span><br><span class="line">    strncpy(arr1,arr2,5);</span><br><span class="line">    printf(&quot;%s\n&quot;,arr1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">strncat</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char arr1[30] = &quot;hello&quot;;</span><br><span class="line">    char arr2[] = &quot;world&quot;;</span><br><span class="line">    strncat(arr1,arr2,5);</span><br><span class="line">    printf(&quot;%s\n&quot;,arr1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strncmp-字符串比较"><a href="#strncmp-字符串比较" class="headerlink" title="strncmp-字符串比较"></a>strncmp-字符串比较</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char* p1 = &quot;abzdef&quot;;</span><br><span class="line">    char* p2 = &quot;abcdewr&quot;;</span><br><span class="line">    int ret = strncmp(p1,p2,6);</span><br><span class="line">    printf(&quot;%d\n&quot;,ret);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strstr-查找字符串"><a href="#strstr-查找字符串" class="headerlink" title="strstr - 查找字符串"></a>strstr - 查找字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* my_strstr(char* p1,const char* p2)</span><br><span class="line">&#123;</span><br><span class="line">    assert(p1 != NULL);</span><br><span class="line">    assert(p2 != NULL);</span><br><span class="line">    char *s1 = p1;</span><br><span class="line">    char *s2 = p2;</span><br><span class="line">    char *cur = (char*)p1;</span><br><span class="line">    if(*p2 == &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        return (char*)p1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (*cur)</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = cur;</span><br><span class="line">        s2 = (char*)p2;</span><br><span class="line">        while ((*s1 != &#x27;\0&#x27;) &amp;&amp; (*s2 != &#x27;\0&#x27;) &amp;&amp; (*s1 == *s2))</span><br><span class="line">        &#123;</span><br><span class="line">            s1++;</span><br><span class="line">            s2++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*s2 == &#x27;\0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return cur;//找到子串</span><br><span class="line">        &#125;</span><br><span class="line">        if(*s1 == &#x27;\0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;//找不到子串</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1 = &quot;abb&quot;;</span><br><span class="line">    char *p2 = &quot;bbc&quot;;</span><br><span class="line">    char* ret = my_strstr(p1,p2);</span><br><span class="line">    if(ret == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;子串不存在\n&quot;);</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strtok-分隔字符串的特点符号"><a href="#strtok-分隔字符串的特点符号" class="headerlink" title="strtok-分隔字符串的特点符号"></a>strtok-分隔字符串的特点符号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    char arr[] = &quot;192@.16@8.17.@80&quot;;</span><br><span class="line">    char* p = &quot;@.&quot;;</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    strcpy(buf,arr);</span><br><span class="line">    char* ret = NULL;</span><br><span class="line">    for(ret = strtok(arr,p);ret != NULL;ret= strtok(NULL,p))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    //切割buf中的字符串</span><br><span class="line">    //char* ret = strtok(arr,p);</span><br><span class="line">    //printf(&quot;%s\n&quot;,ret);</span><br><span class="line">    //ret = strtok(NULL,p);</span><br><span class="line">    //printf(&quot;%s\n&quot;,ret);</span><br><span class="line">    //ret = strtok(NULL,p);</span><br><span class="line">    //printf(&quot;%s\n&quot;,ret);</span><br><span class="line">    //return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strerror-错误信息提示"><a href="#strerror-错误信息提示" class="headerlink" title="strerror-错误信息提示"></a>strerror-错误信息提示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //错误码 错误信息</span><br><span class="line">    //0-    No error</span><br><span class="line">    //1-    Operation not permitted</span><br><span class="line">    //2-    No such file or directory</span><br><span class="line">    //errno 是一个全局的错误码变量</span><br><span class="line">    //当C语言的库函数在执行过程中，发生了错误，就会把对应的错误码，赋值到errno中</span><br><span class="line">    //char* str = strerror(errno);</span><br><span class="line">    //打开文件</span><br><span class="line">    FILE* pf = fopen(&quot;CMakeLists.txt&quot;,&quot;r&quot;);</span><br><span class="line">    if(pf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;错误原因：%s\n&quot;, strerror(errno));</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;打开文件成功了\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memcpy-内存拷贝"><a href="#memcpy-内存拷贝" class="headerlink" title="memcpy-内存拷贝"></a>memcpy-内存拷贝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memcpy-只要处理 不重叠的内存拷贝就可以了</span><br><span class="line">menmove-处理重叠内存的拷贝</span><br><span class="line">----------------------------------------------</span><br><span class="line">struct S</span><br><span class="line">&#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">void* my_memcpy(void* dest,const void* src,size_t num)</span><br><span class="line">&#123;</span><br><span class="line">    void* ret = dest;</span><br><span class="line">    assert(dest != NULL);</span><br><span class="line">    assert(src != NULL);</span><br><span class="line">    while (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(char*)dest = *(char*)src;</span><br><span class="line">        ++dest;</span><br><span class="line">        ++src;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr1[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    int arr2[10] = &#123;0&#125;;</span><br><span class="line">    struct S arr3[] = &#123;&#123;&quot;张三&quot;,20&#125;,&#123;&quot;李帅&quot;,18&#125;&#125;;</span><br><span class="line">    struct S arr4[3] = &#123;0&#125;;</span><br><span class="line">    my_memcpy(arr4,arr3, sizeof(arr3));</span><br><span class="line">    //memcpy(arr4,arr3, sizeof(arr3));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memmove-字节拷贝"><a href="#memmove-字节拷贝" class="headerlink" title="memmove-字节拷贝"></a>memmove-字节拷贝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">覆盖之前重叠区域的字节</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">void* my_memmove(void* dest,const void* src,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    void* ret = dest;</span><br><span class="line">    assert(dest != NULL);</span><br><span class="line">    assert(src != NULL);</span><br><span class="line">    if(dest &lt; src)</span><br><span class="line">    &#123;</span><br><span class="line">        //前-&gt;后</span><br><span class="line">        while (count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *(char*)dest = *(char*)src;</span><br><span class="line">            ++dest;</span><br><span class="line">            ++src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        //后-&gt;前</span><br><span class="line">        while (count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *((char*)dest + count) = *((char*)src + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    my_memmove(arr,arr+2,20);</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memcmp-比较内存"><a href="#memcmp-比较内存" class="headerlink" title="memcmp-比较内存"></a>memcmp-比较内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr1[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    int arr2[] = &#123;1,2,5,4,5&#125;;</span><br><span class="line">    int art = memcmp(arr1,arr2,9);</span><br><span class="line">    printf(&quot;%d\n&quot;,art);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memset-内存设置"><a href="#memset-内存设置" class="headerlink" title="memset-内存设置"></a>memset-内存设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[10] = &#123;0&#125;;</span><br><span class="line">    int ast = memset(arr,1,10);</span><br><span class="line">    printf(&quot;%d\n&quot;,ast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/09/28/test1/</url>
    <content><![CDATA[<p>这里将记录我在学习过程中所遇到的问题，我会将这些问题分享给你们，感谢谢谢关注！！</p>
]]></content>
  </entry>
  <entry>
    <title>我的恋爱日记</title>
    <url>/2021/10/10/love/</url>
    <content><![CDATA[<p>这个专属于我跟卢楷琪的专属回忆</p>
<span id="more"></span>
<h2 id="The-first-love-record"><a href="#The-first-love-record" class="headerlink" title="The first love record."></a>The first love record.</h2><p>  On August 3rd, we met. At that time, we were all together with a playful attitude.With every heart-to-heart conversation in the next few nights,we put down our guard against each other and started to be together with our hearts. During that time, we were all very happy, without quarrels,and wanted to be like newly married couples. I remember that I made a lot of promises to you. I remember all those promises, and I put many of you in my heart. You know,when you said you were willing to marry me in the future, I was really happy.I would treat you like a wife. This is my response to your willingness to marry me, baby.Every communication will bring us closer to each other. May we keep going down this road and love you.</p>
<p>8月3号，我们俩相遇在一起了，当时我们都是怀着玩玩的心态在一起，随着后面几个夜晚我们每一次的交心式的谈话，我们放下了对彼此的戒备心，开始用心在一起，那段时间我们都很快乐，没有争吵，很想新婚一样的夫妻一样,我记得我给你说了很多承诺，那些承诺我都是记得的，你的很多很多我都是放到心上的，也会去努力实现的，你知道吗，当是你说愿意以后嫁给我的时候，我真的很开心很开心，我会像对你如妻子一般，这是我对你愿意嫁给我的回应，宝贝，每一次的交流都会让我们彼此更加靠近对方，愿我们在这条路下一直走下去</p>
<h2 id="Second-love-record"><a href="#Second-love-record" class="headerlink" title="Second love record"></a>Second love record</h2><p>On September 20, we quarreled formally for the first time and you broke up with me for the first time. I was very sad. I couldn’t bear you and you couldn’t bear me. I knew what you said at that time, but at the moment you broke up, my heart trembled. Afterwards, we made up and knew why you were angry. I didn’t want to do this, I don’t know when we often make each other angry. I know you love me and I love you very much, so we didn’t separate. I miss that time in the summer vacation very much. We didn’t quarrel and cherish each other and understand each other very much. Later, I thought, maybe I didn’t give you enough sense of security to make you think I didn’t love you so much, Let you think I don’t care about you very much, but you happen to think wrong. I care about and love you very much. Maybe my way is wrong, which makes you feel like this.</p>
<p>9月20号，我们俩正式第一次吵架，也是你第一次跟我提出分手，我很难过，舍不得你，你也舍不得我，我知道你当时说的气话，可是你提出分手的那一刻我心颤了一下，事后我们和好了，知道你为什么会生气，我也不想这样，不知道从什么时候开始我们经常惹对方生气，我知道你是爱我的，我也很爱你，所以我们没有分开，我很怀恋暑假那段时光，我们俩没有争吵，对彼此都是很珍惜，很谅解对方的，后面我想了想，可能是我给你的安全感不够，让你觉得我不是那么爱你，让你觉得我不是很在乎你，但是你恰好想错了，我是很在乎很爱你的，可能是我的方式错了，让你有这样的感觉</p>
<h2 id="Third-love-record"><a href="#Third-love-record" class="headerlink" title="Third love record"></a>Third love record</h2><p>On October 2, you said to me very seriously about breaking up for the first time. I was very afraid. For the first time, I was so afraid of losing someone. I always begged you not to break up with me, but you insisted on breaking up. At that time, I didn’t understand why you broke up with me. It was very uncomfortable. At that time, I cried. I really cried. You know, my father was beaten and I didn’t cry, But I cried when you said we broke up. It was very uncomfortable. Later, I really had no way to retain you. I went to find your best friend. I want to know what’s wrong with me. Your best friend helped us adjust after listening to our process. When you said we didn’t break up, I had an unprecedented relaxation. Later, I figured out why you told me to break up, I made you feel that I don’t care about you. I gave you a cold period when you need my comfort most, which makes you sad and uncomfortable. Baby, I really want to say to you: we are growing up together. I will learn how to love you and tolerate you. If you won’t be sad again, let me love you a little more today than yesterday and a little more tomorrow than today</p>
<p>10月2号，你第一次对我很严肃的说分手，我很害怕，第一次如此害怕失去一个人，我一直求你不要跟我分手，你却很坚决的要分开，当时我很不明白，你为什么要跟我分手，特别难受，那时我哭了，真的哭了，你知道吗，家里出事我忍着没哭，可是你说分手我却哭了，蛮难受的，后面我真的没有什么办法来挽留你，就去找你的闺蜜，我想知道我到底哪里不好，你闺蜜听了我们的过程后帮我们调节好的，当你说我们不分了后，我有种前所未有的放松，后面我想通了你为什么会对我说分手，是我让你觉得我不在乎你，在你最需要我安慰的时间给你了冷漠期，让你伤心、难受，宝贝，我好想对你说：我们在一起就是一起成长的过程，我会学着如何爱你，如何包容你，如何让你不会再难过了，让今天比昨天更爱你一点点，明天比今天更爱你一点点</p>
<h2 id="Fourth-love-record"><a href="#Fourth-love-record" class="headerlink" title="Fourth love record"></a>Fourth love record</h2><p>On October 16, we met for the first time. You were very nervous, so was I. I held your hand. Your hand was cold and cool. I wanted to warm your hand. Later, you took me to the water bar. We kissed here for the first time. You didn’t refuse me. I was really happy. Your lips were sweet and wanted to kiss you all the time, On my way back, I remembered the feeling of our kissing and found that I seemed addicted. I really like the feeling of kissing with you. Every time I recall the process of kissing with you, my heart will have a palpitating feeling</p>
<p>10月16号，我们第一次见面，你很紧张，我也是，我拉着你的手，你手冰冰凉凉，我想让你的手温暖起来，后面你带我去了水吧，我们在这里进行我们的第一次接吻，你没有拒绝我，我真的很开心，你的嘴唇甜甜的，很想很想跟你一直吻下去，在我回去的路上回味我们接吻的感觉，发现我好像上瘾了，真的好喜欢和你接吻的感觉，每次回忆跟你接吻的过程内心就会有种悸动的感觉</p>
<h2 id="Fifth-love-record"><a href="#Fifth-love-record" class="headerlink" title="Fifth love record"></a>Fifth love record</h2><p>On October 23, we met for the second time. I was a little excited when I was waiting for you in the milk tea shop. I was very happy when I saw you. I wanted to hold your hand. You were afraid that you wouldn’t let me meet the teacher, but I was still very happy. Next to me was the person I loved. This time you still took me to the water bar. Only you and me. I was so happy when you sat on my lap and kissed me, It’s very comfortable to hold you. I feel very relaxed. If I can, I want to hold you like this all my life</p>
<p>10月23号，我们第二次见面，我在奶茶店一直等你，有点小激动，见到你的时候心里很开心，我想拉着你的手，你怕遇到老师就没让，但我还是很开心，我旁边是我爱的人，这次你还是带我去的水吧，只有你我，你坐在我腿上跟我接吻的时候我好开心啊，抱着你很舒服，感觉自己的心很轻松，如果可以，我想这样抱着你一辈子</p>
<h2 id="Sixth-love-record"><a href="#Sixth-love-record" class="headerlink" title="Sixth love record"></a>Sixth love record</h2><p>On November 3, we have been together for three months. Looking back on our time together, although there are quarrels, we are more happy. I am very happy to be with you. Sometimes I recall why I like you, but I don’t know. I don’t know why I like you, but I just like you. There is no reason. I know that sometimes I will make you angry, I’m also changing. I want to go with you and spend time with you. I hope my life. Let’s look forward to the next three months</p>
<p>11月3号，我们已经在一起三个月了，回想我们在一起的时光，虽然有争吵，但更多的是快乐，能跟你在一起我很快乐，有时候我在回忆自己为什么喜欢你，但我自己也不知道，我不知道为什么喜欢你，但我就是喜欢你，没有什么理由，我知道有时候我会让你生气，我也在改变，我想跟你走下去，和你在一起的时光我希望一生，让我们期待下次三个月的到来</p>
<h2 id="Seventh-love-record"><a href="#Seventh-love-record" class="headerlink" title="Seventh love record"></a>Seventh love record</h2>]]></content>
  </entry>
</search>
